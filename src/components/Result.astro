---
import { z } from 'astro/zod';
import Error from './Error.astro';
interface Props {
    ip: string;
    subnets: number;
}
const { ip, subnets } = Astro.props;
let error = false;
let errorMessage = '';
if (
    !z
        .array(z.coerce.number().min(0).max(255))
        .length(4)
        .safeParse(ip.split('.')).success
) {
    error = true;
    errorMessage = 'Not a valid IP!';
}
if (!z.coerce.number().min(1).safeParse(subnets).success) {
    error = true;
    errorMessage = 'Number of subnets must be >= 1!';
}
const first = parseInt(ip).toString(2).padStart(8, '0').split('');
const totalBits = 32;
let defaultNetworkBits: 8 | 16 | 24;
let defaultHostBits: 8 | 16 | 24;
let ipClass: 'A' | 'B' | 'C';
let defaultSubnetMask: '255.0.0.0' | '255.255.0.0' | '255.255.255.0';
let maxSubnets: number;
if (parseInt(first[0]) == 0) {
    ipClass = 'A';
    defaultSubnetMask = '255.0.0.0';
    defaultNetworkBits = 8;
} else {
    if (parseInt(first[1]) == 0) {
        ipClass = 'B';
        defaultSubnetMask = '255.255.0.0';
        defaultNetworkBits = 16;
    } else {
        ipClass = 'C';
        defaultSubnetMask = '255.255.255.0';
        defaultNetworkBits = 24;
    }
}
defaultHostBits = totalBits - defaultNetworkBits;
maxSubnets = Math.pow(2, defaultHostBits);
if (subnets > maxSubnets) {
    error = true;
    errorMessage = `Max number of subnets for a class ${ipClass} address is ${maxSubnets}!`;
}
let binarySubnetMask = defaultSubnetMask
    .split('.')
    .map((n) => parseInt(n).toString(2).padStart(8, '0'))
    .join('');
let bits = Math.ceil(Math.log2(subnets));
let i = 0;
binarySubnetMask = binarySubnetMask.replace(/0/g, () =>
    ++i <= bits ? '1' : '0',
);
const networkBits = binarySubnetMask.replace(/0/g, '').length;
const newSubnetMask = Array.from({ length: 4 }, (_, i) =>
    parseInt(binarySubnetMask.slice(i * 8, (i + 1) * 8), 2),
).join('.');
const hosts = Math.pow(2, totalBits - networkBits);
const validHosts = hosts > 2 ? hosts - 2 : hosts;
---

<span class="font-bold">General information:</span>
<span>IP: {ip}</span>
<span>Number of subnets: {subnets}</span>
<span>Class: {ipClass}</span>
<span class="font-bold">Detailed information:</span>
<span>Default subnet mask: {defaultSubnetMask}</span>
{
    error && (
        <div class="pt-4">
            <Error message={errorMessage} />
        </div>
    )
}
{
    !error && (
        <>
            <span>New subnet mask: {newSubnetMask}</span>
            <span>CIDR notation: /{networkBits}</span>
            <div class="flex gap-x-1">
                <span>Number of hosts for each subnet: {validHosts}</span>
                {validHosts <= 2 && (
                    <span class="font-bold">
                        (Special case when normal rule doesn't apply!)
                    </span>
                )}
            </div>
            <div class="py-4">
                <table>
                    <colgroup>
                        {Array.from({ length: 4 }, () => (
                            <col class="w-64" />
                        ))}
                    </colgroup>
                    <thead class="border-2">
                        <th>Subnet</th>
                        <th>Network IP</th>
                        <th>Hosts Range</th>
                        <th>Broadcast IP</th>
                    </thead>
                    <tbody class="border-2 text-center">
                        {Array.from({ length: subnets }, (_, i) => (
                            <tr>
                                <td>Subnet {i}</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </>
    )
}
