---
import { z } from 'astro/zod';
import count from '../utils/count';
import Error from './Error.astro';
interface Props {
    ip: string;
    subnets: number;
}
const { ip, subnets } = Astro.props;
const first = parseInt(ip).toString(2).split('');
const totalBits = 32;
let ipClass: 'A' | 'B' | 'C';
let defaultSubnetMask: '255.0.0.0' | '255.255.0.0' | '255.255.255.0';
let maxSubnets: number;
let error = false;
let errorMessage = '';
let networkBits: number;
if (parseInt(first[0]) == 0) {
    ipClass = 'A';
    defaultSubnetMask = '255.0.0.0';
    networkBits = 24;
    maxSubnets = Math.pow(2, networkBits);
} else {
    if (parseInt(first[1]) == 0) {
        ipClass = 'B';
        defaultSubnetMask = '255.255.0.0';
        networkBits = 16;
        maxSubnets = Math.pow(2, networkBits);
    } else {
        ipClass = 'C';
        defaultSubnetMask = '255.255.255.0';
        networkBits = 8;
        maxSubnets = Math.pow(2, networkBits);
    }
}
const byteArray = z.array(z.coerce.number().min(0).max(255)).length(4);
if (!byteArray.safeParse(ip.split('.')).success) {
    error = true;
    errorMessage = 'Not a valid IP!';
}
if (subnets > maxSubnets) {
    error = true;
    errorMessage = `Max number of subnets for a class ${ipClass} address is ${maxSubnets}!`;
}
let binarySubnetMask = defaultSubnetMask
    .split('.')
    .map((n) => parseInt(n).toString(2).padStart(8, '0'))
    .join('');
let binarySubnetMaskArray = binarySubnetMask.split('');
let bits = Math.ceil(Math.log2(subnets));
networkBits += bits;
const hostBits = totalBits - networkBits;
for (let i = 0; i < binarySubnetMaskArray.length && bits > 0; i++) {
    if (binarySubnetMaskArray[i] == '0') {
        binarySubnetMaskArray[i] = '1';
        bits--;
    }
}
binarySubnetMask = binarySubnetMaskArray.join('');
const newSubnetMask = Array.from({ length: 4 }, (_, i) =>
    parseInt(binarySubnetMask.slice(i * 8, (i + 1) * 8), 2),
).join('.');
const hosts = Math.pow(2, totalBits - count(binarySubnetMask.split(''), '1'));
const validHosts = hosts > 2 ? hosts - 2 : hosts;
---

<span class="font-bold">General information:</span>
<span>IP: {ip}</span>
<span>Number of subnets: {subnets}</span>
<span>Class: {ipClass}</span>
<span class="font-bold">Detailed information:</span>
<span>Default subnet mask: {defaultSubnetMask}</span>
{
    error && (
        <div class="pt-4">
            <Error message={errorMessage} />
        </div>
    )
}
{
    !error && (
        <>
            <span>
                New subnet mask: {newSubnetMask}/{hostBits}
            </span>
            <div class="flex gap-x-1">
                <span>Number of hosts for each subnet: {validHosts}</span>
                {validHosts <= 2 && (
                    <span class="font-bold">
                        (Special case when normal rule doesn't apply!)
                    </span>
                )}
            </div>
            <div class="py-4">
                <table>
                    <colgroup>
                        {Array.from({ length: 4 }, () => (
                            <col class="w-64" />
                        ))}
                    </colgroup>
                    <thead class="border-2">
                        <th>Subnet</th>
                        <th>Network IP</th>
                        <th>Hosts Range</th>
                        <th>Broadcast IP</th>
                    </thead>
                    <tbody class="border-2 text-center">
                        {Array.from({ length: subnets }, (_, i) => (
                            <tr>
                                <td>Subnet {i}</td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
        </>
    )
}
